# k-ratio Maps

k-ratio maps are an excellent way to display elemental information in a manner that is
much more quantitative than elemental maps.  There are two major differences between
elemental maps and k-ratio maps:
  1. k-ratios are the first approximation to composition.  The compensate for differences in generation efficiency between elements.
  2. They are background corrected so that differences in continuum intensity won't be mistaken for differences in trace elements.
```julia
using DrWatson
@quickactivate("HyperspectraWithNeXL")

using NeXLSpectrum
using Gadfly
using LinearAlgebra
using Images
using FileIO
```
Load the hyperspectrum from a RPL/RAW file.
```julia
path = joinpath(datadir(),"exp_raw","Mn Nodule")

lt = 0.72*4.0*18.0*3600.0/(1024*1024) # 18.0 hours on 4 detectors
hs = NeXLSpectrum.compress(HyperSpectrum(
    LinearEnergyScale(0.0,10.0),
    Dict{Symbol,Any}(
      :TakeOffAngle => deg2rad(35.0),
      :ProbeCurrent => 1.0, 
      :LiveTime => lt, 
      :BeamEnergy => 20.0e3, 
      :Name => splitdir(path)[2]),
    readrplraw(joinpath(path,"map[15]"))
));
```

Plot the max-pixel spectrum to determine which elements are present.
```julia; fig_height=3; fig_width=10; fig_ext=".svg";
mp = maxpixel(hs)
plot(mp, klms=[ n"C", n"O", n"Ag", n"Al", n"Ba", n"Ca", n"Cr", n"Cl", n"Fe", #
                n"S", n"P", n"Cu", n"K", n"Mg", n"Mn", n"Na", n"Ni", n"Si", #
                n"Ti", n"Zn", n"Os" ], xmax=10.0e3)
```

Create a `FilterFitPacket` with the fitting standards.
```julia
refpath = joinpath(path, "Standards")
refs = references( [
    reference(n"Ag", joinpath(refpath, "Ag std.msa") ),
    reference(n"Al", joinpath(refpath, "Al std.msa") ),
    reference(n"C", joinpath(refpath, "C std.msa") ),
    reference(n"Ca", joinpath(refpath, "CaF2 std.msa") ),
    reference(n"Ce", joinpath(refpath, "CeO2 std.msa") ),
    reference(n"Cl", joinpath(refpath, "NaCl std.msa") ),
    reference(n"Cr", joinpath(refpath, "Cr std.msa") ),
    reference(n"Cu", joinpath(refpath, "Cu std.msa") ),
    reference(n"Fe", joinpath(refpath, "Fe std.msa") ),
    reference(n"S", joinpath(refpath, "FeS2 std.msa") ),
    reference(n"P", joinpath(refpath, "GaP std.msa") ),
    reference(n"K", joinpath(refpath, "KBr std.msa") ),
    reference(n"Mg", joinpath(refpath, "Mg std.msa") ),
    reference(n"O", joinpath(refpath, "MgO std.msa") ),
    reference(n"Mn", joinpath(refpath, "Mn std.msa") ),
    reference(n"Na", joinpath(refpath, "NaCl std.msa") ),
    reference(n"Ni", joinpath(refpath, "Ni std.msa") ),
    reference(n"Si", joinpath(refpath, "Si std.msa") ),
    reference(n"Ti", joinpath(refpath, "Ti std.msa") ),
    reference(n"Zn", joinpath(refpath, "Zn std.msa") ) ], 
    132.0
)
```
Fit the hyperspectral data.  The :Fast mode is usually adequate for display purposes
and orders-of-magnitude faster than alternatives.
```julia
resf = @time fit_spectrum(hs, refs, mode = :Fast)
```
Determine the optimal k-ratio for each element.
```julia
bestks = optimizeks(SimpleKRatioOptimizer(2.0), resf)
```
Create normalized k-ratio maps.   Normalized k-ratio maps are an excellent way to present
elemental data in a quantitative manner.
```julia; fig_height=10; fig_width=10; fig_ext=".svg";
# Normalize the k-ratios for presentation
bestf = LinearAlgebra.normalize(bestks);
output = joinpath(plotsdir(),"Mn Nodule","Quant")
mkpath(output)
foreach(bf->FileIO.save(File(format"PNG", joinpath(output,"k[$(symbol(bf[1].element))][Log3].png")), Log3Band.(bf[2])),bestf)
foreach(bf->FileIO.save(File(format"PNG", joinpath(output,"k[$(symbol(bf[1].element))][Linear].png")), LinearScale.(bf[2])),bestf)
display(labeledimages(["$(bf[1].xrays)" for bf in bestf],[Log3Band.(bf[2]) for bf in bestf], ncols=4))
```

Finally extract a RGB colorized image from three elements.  :Each normalizes each element independently.
:All normalizes the k-ratios relative to all the `KRatios`.
```julia
colorize(bestks, n"Mn", n"O", n"Fe", :Each)
```
```julia
colorize(bestks, n"Mn", n"O", n"Fe", :All)
```
