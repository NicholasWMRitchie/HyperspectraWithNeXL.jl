```julia
using DrWatson
@quickactivate("HyperspectraWithNeXL")

using NeXLSpectrum
using NeXLMatrixCorrection
using NeXLParticle
using DataFrames
using Images
using FileIO
using Gadfly
using LinearAlgebra
using Statistics
using Cairo, Fontconfig
```
Load the hyperspectrum from a RPL/RAW file.
```julia
path = joinpath(datadir(),"exp_raw","Mn Nodule")

lt = 0.72*4.0*18.0*3600.0/(1024*1024) # 18.0 hours on 4 detectors
hs = NeXLSpectrum.compress(HyperSpectrum(
    LinearEnergyScale(0.0,10.0),
    Dict{Symbol,Any}(
      :TakeOffAngle => deg2rad(35.0),
      :ProbeCurrent => 1.0, 
      :LiveTime => lt, 
      :BeamEnergy => 20.0e3, 
      :Name => splitdir(path)[2]),
    readrplraw(joinpath(path,"map[15]"))
))
hs[:Detector] = matching(hs, 132.0)
#hs = view(hs,1:64:1024,1:64:1024)
```

Create a `FilterFitPacket` with the fitting standards.
```julia; fig_height=3; fig_width=10; fig_ext=".svg";
refpath = joinpath(path, "Standards")
refs = references( [
    reference(n"Ag", joinpath(refpath, "Ag std.msa") ),
    reference(n"Al", joinpath(refpath, "Al std.msa") ),
    reference(n"C", joinpath(refpath, "C std.msa") ),
    reference(n"Ca", joinpath(refpath, "CaF2 std.msa") ),
    reference(n"Ce", joinpath(refpath, "CeO2 std.msa") ),
    reference(n"Cl", joinpath(refpath, "NaCl std.msa") ),
    reference(n"Cr", joinpath(refpath, "Cr std.msa") ),
    reference(n"Cu", joinpath(refpath, "Cu std.msa") ),
    reference(n"Fe", joinpath(refpath, "Fe std.msa") ),
    reference(n"S", joinpath(refpath, "FeS2 std.msa") ),
    reference(n"P", joinpath(refpath, "GaP std.msa") ),
    reference(n"K", joinpath(refpath, "KBr std.msa") ),
    reference(n"Mg", joinpath(refpath, "Mg std.msa") ),
    reference(n"O", joinpath(refpath, "MgO std.msa") ),
    reference(n"Mn", joinpath(refpath, "Mn std.msa") ),
    reference(n"Na", joinpath(refpath, "NaCl std.msa") ),
    reference(n"Ni", joinpath(refpath, "Ni std.msa") ),
    reference(n"Si", joinpath(refpath, "Si std.msa") ),
    reference(n"Ti", joinpath(refpath, "Ti std.msa") ),
    reference(n"Zn", joinpath(refpath, "Zn std.msa") ) ], 132.0
)
# Plot the max-pixel against the reference elements
plot(maxpixel(hs), klms=elms(refs), xmax=10.0e3)
```
Fit the hyperspectral data to extract k-ratios.
```julia
resf = @time fit_spectrum(hs, refs, mode = :Full)
```
`resf` is an `Array{KRatios}`. 

Quantify the k-ratios to get the compositions.
```julia
res = @time quantify(resf);
```
`res` is an `Array{Material}`.

Look at the analytical totals.
```julia
atr = analyticaltotal.(res)
( mean(atr), std(atr), extrema(atr)...)
```

Let's define a function `extract(...)` to extract the mass-fraction associated with `elm`
from an array of `Material`.  This will construct an array the same shape as `mat` but
containing `Float64` representing the mass fraction of `elm`.
```julia
extract(mats::AbstractArray{<:Material}, elm::Element) = map(m->NeXLUncertainties.value(m[elm]), mats)
```

Construct images with various different presentation of the elemental data - a regular gray-scale image, a Mask
of all pixels with mass-fraction of `elm` > 0.1 and a Bright-style Log 3-band image.  Write these to disk as PNG images.
```julia; fig_height=6; fig_width=6; fig_ext=".png";
output = joinpath(plotsdir(),"Mn Nodule","Quant")
# Convert low analytical totals (maybe voids?) to a null material.
toblack(mat) = analyticaltotal(mat)<0.5 ? NeXLCore.NULL_MATERIAL : mat
# Normalize the mass-fractions to [0.0, 1.0] while setting low totals to zero.
resn = asnormalized.(toblack.(res))
for elm in elms(refs)
    elmq = extract(resn, elm)
    # A regular gray-scale image representing each element
    FileIO.save(joinpath(output, "Quant[$(symbol(elm))][Linear].png"), Gray.(elmq))
    # A mask representing each point at which the mass-fraction is greater than 0.1
    FileIO.save(joinpath(output,"Mask[$(symbol(elm)) gt 0.1].png"), Gray.(elmq.>0.1))
    # A Log 3-band image representing the mass fractions
    FileIO.save(joinpath(output, "Quant[$(symbol(elm))][Log3band].png"), Log3Band.(elmq))
end

# Construct gray-scale images and display them in this document.
imgs = map(el->Gray.(extract(resn, el)), elms(refs)) 
display.(imgs);
```

Construct an RGB colorized view with Mn=>red, C=>green and O=>blue.
```julia; fig_height=6; fig_width=6; fig_ext=".png";
colorview(RGB, extract(resn, n"Mn"), extract(resn,n"C"), extract(resn,n"O"))
```

Cluster on composition rather than k-ratio.
```julia; fig_height=6; fig_width=6; fig_ext=".svg";
els = elms(refs)
dv = DiluvianCluster(els, map(el->extract(resn, el), els), bin=x->floor(Integer, min(1.0, max(0.0, x)) * 10.0))
climg = asimage(dv)
FileIO.save(joinpath(output, "ClusterMap.png"), climg)
labeledimage("Clustered Map Data", climg)
```

```julia; fig_height=2; fig_width=3; fig_ext=".svg";
NeXLParticle.defaultpalette(dv)
```

Construct a ternary to display common types of pixels.
```julia; fig_height=6; fig_width=6; fig_ext=".svg";
# Select those clusters with more than 100 pixels.
cl = collect(filter(i->count(dv,i)>100, eachindex(dv)));
multiternary(dv, cl; maxitems = 2500)
```

Plot the sum spectrum and a pixel mask. 
```julia; fig_height=3; fig_width=8; fig_ext=".svg";
for i in cl
    mask = asmask(dv,i)
    cs = sum(hs, mask ,name="Cluster $i")
    display(plotandimage(plot(cs, xmax=10.0e3, klms = elms(refs)),Gray.(mask)))
end
```

Summarize these classes in a table
```julia
ENV["columns"]=500
asa(DataFrame, map(i->mean(res[asmask(dv, i)]), cl))
```

